{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"lab1/db/","text":"from sqlmodel import SQLModel, Session, create_engine db_url = 'postgresql://postgres:12345@localhost/finances' engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_db(): with Session(engine) as session: yield session","title":"db.py"},{"location":"lab1/endpoints/","text":"from fastapi import FastAPI, Depends, HTTPException from models import * from db import * app = FastAPI() @app.on_event(\"startup\") def on_startup(): init_db() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} @app.get(\"/user/{user_id}\", response_model=UserDisplay) def get_user(user_id: int, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.get(\"/users\", response_model=List[User]) def get_users(db: Session = Depends(get_db)): return db.query(User).all() @app.post(\"/user\") def create_user(user: UserBase, db: Session = Depends(get_db)): db_user = User(**user.dict()) db.add(db_user) db.commit() db.refresh(db_user) return db_user @app.delete(\"/user/{user_id}\") def delete_user(user_id: int, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") db.delete(db_user) db.commit() return {\"message\": \"User deleted successfully\"} @app.patch(\"/user/{user_id}\") def update_user(user_id: int, user: UserBase, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") for attr, value in user.dict().items(): setattr(db_user, attr, value) db.commit() db.refresh(db_user) return db_user # Endpoints for Budget CRUD operations @app.get(\"/budget/{budget_id}\", response_model=BudgetDisplay) def get_budget(budget_id: int, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") return db_budget @app.get(\"/budgets\", response_model=List[Budget]) def get_budgets(db: Session = Depends(get_db)): return db.query(Budget).all() @app.post(\"/budget\") def create_budget(budget: BudgetBase, db: Session = Depends(get_db)): db_budget = Budget(**budget.dict()) db.add(db_budget) db.commit() db.refresh(db_budget) return db_budget @app.delete(\"/budget/{budget_id}\") def delete_budget(budget_id: int, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") db.delete(db_budget) db.commit() return {\"message\": \"Budget deleted successfully\"} @app.patch(\"/budget/{budget_id}\") def update_budget(budget_id: int, budget: BudgetBase, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") for attr, value in budget.dict().items(): setattr(db_budget, attr, value) db.commit() db.refresh(db_budget) return db_budget # Endpoints for Category CRUD operations @app.get(\"/category/{category_id}\", response_model=CategoryDisplay) def get_category(category_id: int, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") return db_category @app.get(\"/categories\", response_model=List[Category]) def get_categories(db: Session = Depends(get_db)): return db.query(Category).all() @app.post(\"/category\") def create_category(category: CategoryBase, db: Session = Depends(get_db)): db_category = Category(**category.dict()) db.add(db_category) db.commit() db.refresh(db_category) return db_category @app.delete(\"/category/{category_id}\") def delete_category(category_id: int, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") db.delete(db_category) db.commit() return {\"message\": \"Category deleted successfully\"} @app.patch(\"/category/{category_id}\") def update_category(category_id: int, category: CategoryBase, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") for attr, value in category.dict().items(): setattr(db_category, attr, value) db.commit() db.refresh(db_category) return db_category # Endpoints for Income CRUD operations @app.get(\"/income/{income_id}\", response_model=IncomeDisplay) def get_income(income_id: int, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") return db_income @app.get(\"/incomes\", response_model=List[Income]) def get_incomes(db: Session = Depends(get_db)): return db.query(Income).all() @app.post(\"/income\") def create_income(income: IncomeBase, db: Session = Depends(get_db)): db_income = Income(**income.dict()) db.add(db_income) db.commit() db.refresh(db_income) return db_income @app.delete(\"/income/{income_id}\") def delete_income(income_id: int, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") db.delete(db_income) db.commit() return {\"message\": \"Income deleted successfully\"} @app.patch(\"/income/{income_id}\") def update_income(income_id: int, income: IncomeBase, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") for attr, value in income.dict().items(): setattr(db_income, attr, value) db.commit() db.refresh(db_income) return db_income # Endpoints for Expense CRUD operations @app.get(\"/expense/{expense_id}\", response_model=ExpenseDisplay) def get_expense(expense_id: int, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") return db_expense @app.get(\"/expenses\", response_model=List[Expense]) def get_expenses(db: Session = Depends(get_db)): return db.query(Expense).all() @app.post(\"/expense\") def create_expense(expense: ExpenseBase, db: Session = Depends(get_db)): db_expense = Expense(**expense.dict()) db.add(db_expense) db.commit() db.refresh(db_expense) return db_expense @app.delete(\"/expense/{expense_id}\") def delete_expense(expense_id: int, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") db.delete(db_expense) db.commit() return {\"message\": \"Expense deleted successfully\"} @app.patch(\"/expense/{expense_id}\") def update_expense(expense_id: int, expense: ExpenseBase, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") for attr, value in expense.dict().items(): setattr(db_expense, attr, value) db.commit() db.refresh(db_expense) return db_expense","title":"Main.py"},{"location":"lab1/env/","text":"from logging.config import fileConfig from sqlalchemy import engine_from_config from sqlalchemy import pool from alembic import context from models import * import os from dotenv import load_dotenv load_dotenv() # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context.config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig(config.config_file_name) config.set_main_option('sqlalchemy.url', os.getenv('DB_ADMIN')) # add your model's MetaData object here # for 'autogenerate' support # from myapp import mymodel # target_metadata = mymodel.Base.metadata #target_metadata = None target_metadata = SQLModel.metadata # other values from the config, defined by the needs of env.py, # can be acquired: # my_important_option = config.get_main_option(\"my_important_option\") # ... etc. def run_migrations_offline() -> None: \"\"\"Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the script output. \"\"\" url = config.get_main_option(\"sqlalchemy.url\") context.configure( url=url, target_metadata=target_metadata, literal_binds=True, dialect_opts={\"paramstyle\": \"named\"}, ) with context.begin_transaction(): context.run_migrations() def run_migrations_online() -> None: \"\"\"Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. \"\"\" connectable = engine_from_config( config.get_section(config.config_ini_section, {}), prefix=\"sqlalchemy.\", poolclass=pool.NullPool, ) with connectable.connect() as connection: context.configure( connection=connection, target_metadata=target_metadata ) with context.begin_transaction(): context.run_migrations() if context.is_offline_mode(): run_migrations_offline() else: run_migrations_online()","title":"env.py"},{"location":"lab1/models/","text":"from datetime import datetime from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship class BudgetBase(SQLModel): amount: float date_valid_until: datetime user_id: int = Field(foreign_key=\"user.id\") category_id: int = Field(foreign_key=\"category.id\") class PageBase(SQLModel): title: str url: str class Page(PageBase, table=True): id: int = Field(default=None, primary_key=True) class BudgetDisplay(BudgetBase): user: Optional[\"User\"] = None category: Optional[\"Category\"] = None incomes: Optional[List[\"Income\"]] = None expenses: Optional[List[\"Expense\"]] = None class Budget(BudgetBase, table=True): id: int = Field(default=None, primary_key=True) user: Optional[\"User\"] = Relationship(back_populates=\"budgets\") category: Optional[\"Category\"] = Relationship(back_populates=\"budgets\") incomes: Optional[List[\"Income\"]] = Relationship(back_populates=\"budget\") expenses: Optional[List[\"Expense\"]] = Relationship(back_populates=\"budget\") class UserBase(SQLModel): username: str email: str password: str class UserDisplay(UserBase): categories: List[\"Category\"] = None budgets: List[\"Budget\"] = None class User(UserBase, table=True): id: int = Field(default=None, primary_key=True) categories: List[\"Category\"] = Relationship(back_populates=\"user\", link_model=Budget) budgets: List[\"Budget\"] = Relationship(back_populates=\"user\") class CategoryBase(SQLModel): name: str description: str class CategoryDisplay(CategoryBase): budgets: List[\"Budget\"] = None user: List[\"User\"] = None class Category(CategoryBase, table=True): id: int = Field(default=None, primary_key=True) budgets: List[\"Budget\"] = Relationship(back_populates=\"category\") user: List[\"User\"] = Relationship(back_populates=\"categories\", link_model=Budget) class IncomeBase(SQLModel): amount: float description: str date: datetime = Field(default=datetime.utcnow) budget_id: int = Field(foreign_key=\"budget.id\") class IncomeDisplay(IncomeBase): budget: Budget = None class Income(IncomeBase, table=True): id: int = Field(default=None, primary_key=True) budget: Budget = Relationship(back_populates=\"incomes\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) class ExpenseBase(SQLModel): amount: float description: str date: datetime = Field(default=datetime.utcnow) budget_id: int = Field(foreign_key=\"budget.id\") class ExpenseDisplay(ExpenseBase): budget: Budget = None class Expense(ExpenseBase, table=True): id: int = Field(default=None, primary_key=True) budget: Budget = Relationship(back_populates=\"expenses\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } )","title":"Models.py"},{"location":"lab1/practise/","text":"","title":"Practise"},{"location":"lab1/task/","text":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0441\u0435\u0440\u0432\u0438\u0441 \u0434\u043b\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043b\u0438\u0447\u043d\u044b\u043c\u0438 \u0444\u0438\u043d\u0430\u043d\u0441\u0430\u043c\u0438. \u0421\u0435\u0440\u0432\u0438\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c \u0432\u0432\u043e\u0434\u0438\u0442\u044c \u0434\u043e\u0445\u043e\u0434\u044b \u0438 \u0440\u0430\u0441\u0445\u043e\u0434\u044b, \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0442\u044c \u0431\u044e\u0434\u0436\u0435\u0442\u044b \u043d\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0442\u0447\u0435\u0442\u044b \u043e \u0441\u0432\u043e\u0438\u0445 \u0444\u0438\u043d\u0430\u043d\u0441\u0430\u0445. \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0433\u0443\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0432 \u0441\u0435\u0431\u044f \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u0439 \u043e \u043f\u0440\u0435\u0432\u044b\u0448\u0435\u043d\u0438\u0438 \u0431\u044e\u0434\u0436\u0435\u0442\u0430, \u0430\u043d\u0430\u043b\u0438\u0437\u0430 \u0442\u0440\u0430\u0442 \u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0446\u0435\u043b\u0435\u0439 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435. \u041a\u0440\u0438\u0442\u0435\u0440\u0438\u0438 \u043c\u043e\u0434\u0435\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0445: 5 \u0438\u043b\u0438 \u0431\u043e\u043b\u044c\u0448\u0435 \u0442\u0430\u0431\u043b\u0438\u0446 \u0421\u0432\u044f\u0437\u0438 many-to-many \u0438 one-to-many \u0410\u0441\u0441\u043e\u0446\u0438\u0430\u0442\u0438\u0432\u043d\u0430\u044f \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u044c \u0434\u043e\u043b\u0436\u043d\u0430 \u0438\u043c\u0435\u0442\u044c \u043f\u043e\u043b\u0435, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0437\u0443\u044e\u0449\u0435\u0435 \u0441\u0432\u044f\u0437\u044c, \u043f\u043e\u043c\u0438\u043c\u043e \u0441\u0441\u044b\u043b\u043e\u043a \u043d\u0430 \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u043d\u0430 9 \u0411\u0430\u043b\u043b\u043e\u0432 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0439 \u043c\u043e\u0434\u0435\u043b\u0438 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0439 \u0438\u0437 \u043f\u0440\u0430\u043a\u0442\u0438\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0430 FastAPI. \u041e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0432 \u0441\u0435\u0431\u044f: \u0422\u0430\u0431\u043b\u0438\u0446\u044b, \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ORM SQLAlchemy \u0438\u043b\u0438 SQLModel \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0411\u0414 PostgreSQL. API, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 CRUD-\u044b. \u0422\u0430\u043c \u0433\u0434\u0435 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e, \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c GET-\u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0438 \u0441 \u0432\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u043c\u0438 \u043e\u0431\u044a\u0435\u043a\u0442\u0430\u043c\u0438 (\u0441\u0432\u044f\u0437\u0438 many-to-many \u0438 one-to-many). \u041d\u0430\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443 \u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 Alembic. \u0410\u043d\u043d\u043e\u0442\u0430\u0446\u0438\u044e \u0442\u0438\u043f\u043e\u0432 \u0432 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0445 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u0445 \u0432 API-\u043c\u0435\u0442\u043e\u0434\u0430\u0445. \u041e\u0444\u043e\u0440\u043c\u043b\u0435\u043d\u043d\u0443\u044e \u0444\u0430\u0439\u043b\u043e\u0432\u0443\u044e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0441 \u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u0435\u043c \u043a\u043e\u0434\u0430, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0435\u0433\u043e \u0437\u0430 \u0440\u0430\u0437\u043d\u0443\u044e \u0431\u0438\u0437\u043d\u0435\u0441-\u043b\u043e\u0433\u0438\u043a\u0443 \u0438 \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u043d\u0443\u044e \u043e\u0431\u043b\u0430\u0441\u0442\u044c, \u043d\u0430 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0438 \u043f\u0430\u043f\u043a\u0438.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435"},{"location":"lab1/task/#_1","text":"\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0441\u0435\u0440\u0432\u0438\u0441 \u0434\u043b\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043b\u0438\u0447\u043d\u044b\u043c\u0438 \u0444\u0438\u043d\u0430\u043d\u0441\u0430\u043c\u0438. \u0421\u0435\u0440\u0432\u0438\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c \u0432\u0432\u043e\u0434\u0438\u0442\u044c \u0434\u043e\u0445\u043e\u0434\u044b \u0438 \u0440\u0430\u0441\u0445\u043e\u0434\u044b, \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0442\u044c \u0431\u044e\u0434\u0436\u0435\u0442\u044b \u043d\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0442\u0447\u0435\u0442\u044b \u043e \u0441\u0432\u043e\u0438\u0445 \u0444\u0438\u043d\u0430\u043d\u0441\u0430\u0445. \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0433\u0443\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0432 \u0441\u0435\u0431\u044f \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u0439 \u043e \u043f\u0440\u0435\u0432\u044b\u0448\u0435\u043d\u0438\u0438 \u0431\u044e\u0434\u0436\u0435\u0442\u0430, \u0430\u043d\u0430\u043b\u0438\u0437\u0430 \u0442\u0440\u0430\u0442 \u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0446\u0435\u043b\u0435\u0439 \u043d\u0430 \u0431\u0443\u0434\u0443\u0449\u0435\u0435.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435"},{"location":"lab1/task/#_2","text":"5 \u0438\u043b\u0438 \u0431\u043e\u043b\u044c\u0448\u0435 \u0442\u0430\u0431\u043b\u0438\u0446 \u0421\u0432\u044f\u0437\u0438 many-to-many \u0438 one-to-many \u0410\u0441\u0441\u043e\u0446\u0438\u0430\u0442\u0438\u0432\u043d\u0430\u044f \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u044c \u0434\u043e\u043b\u0436\u043d\u0430 \u0438\u043c\u0435\u0442\u044c \u043f\u043e\u043b\u0435, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0437\u0443\u044e\u0449\u0435\u0435 \u0441\u0432\u044f\u0437\u044c, \u043f\u043e\u043c\u0438\u043c\u043e \u0441\u0441\u044b\u043b\u043e\u043a \u043d\u0430 \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b","title":"\u041a\u0440\u0438\u0442\u0435\u0440\u0438\u0438 \u043c\u043e\u0434\u0435\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0445:"},{"location":"lab1/task/#9","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0439 \u043c\u043e\u0434\u0435\u043b\u0438 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0439 \u0438\u0437 \u043f\u0440\u0430\u043a\u0442\u0438\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043d\u0430 FastAPI. \u041e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0432 \u0441\u0435\u0431\u044f: \u0422\u0430\u0431\u043b\u0438\u0446\u044b, \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ORM SQLAlchemy \u0438\u043b\u0438 SQLModel \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0411\u0414 PostgreSQL. API, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 CRUD-\u044b. \u0422\u0430\u043c \u0433\u0434\u0435 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e, \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c GET-\u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0438 \u0441 \u0432\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u043c\u0438 \u043e\u0431\u044a\u0435\u043a\u0442\u0430\u043c\u0438 (\u0441\u0432\u044f\u0437\u0438 many-to-many \u0438 one-to-many). \u041d\u0430\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443 \u043c\u0438\u0433\u0440\u0430\u0446\u0438\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 Alembic. \u0410\u043d\u043d\u043e\u0442\u0430\u0446\u0438\u044e \u0442\u0438\u043f\u043e\u0432 \u0432 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0445 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u0445 \u0432 API-\u043c\u0435\u0442\u043e\u0434\u0430\u0445. \u041e\u0444\u043e\u0440\u043c\u043b\u0435\u043d\u043d\u0443\u044e \u0444\u0430\u0439\u043b\u043e\u0432\u0443\u044e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0441 \u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u0435\u043c \u043a\u043e\u0434\u0430, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0435\u0433\u043e \u0437\u0430 \u0440\u0430\u0437\u043d\u0443\u044e \u0431\u0438\u0437\u043d\u0435\u0441-\u043b\u043e\u0433\u0438\u043a\u0443 \u0438 \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u043d\u0443\u044e \u043e\u0431\u043b\u0430\u0441\u0442\u044c, \u043d\u0430 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0438 \u043f\u0430\u043f\u043a\u0438.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u043d\u0430 9 \u0411\u0430\u043b\u043b\u043e\u0432"},{"location":"lab2/comparison/","text":"\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 threading \u0438 async \u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043f\u043e\u0445\u043e\u0436\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0434\u043b\u044f \u0447\u0438\u0441\u0442\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0438\u0437-\u0437\u0430 \u0441\u043b\u0430\u0431\u043e\u0433\u043e \u0432\u043b\u0438\u044f\u043d\u0438\u044f GIL \u0432 \u0434\u0430\u043d\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435. Multiprocessing \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u0435\u0435 \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447 \u0441 \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u0438\u043c \u043e\u0431\u044a\u0435\u043c\u043e\u043c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439, \u0438\u0437-\u0437\u0430 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432 \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0443 \u0434\u0430\u043d\u043d\u044b\u0445. Async Threading Multiprocessing \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 0.0239 c. 0.0130 c. 0.1599 c. \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 0.9186 \u0441. 0.5087 \u0441. 1.4160 \u0441.","title":"\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435"},{"location":"lab2/comparison/#_1","text":"threading \u0438 async \u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043f\u043e\u0445\u043e\u0436\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0434\u043b\u044f \u0447\u0438\u0441\u0442\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0438\u0437-\u0437\u0430 \u0441\u043b\u0430\u0431\u043e\u0433\u043e \u0432\u043b\u0438\u044f\u043d\u0438\u044f GIL \u0432 \u0434\u0430\u043d\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435. Multiprocessing \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u0435\u0435 \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447 \u0441 \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u0438\u043c \u043e\u0431\u044a\u0435\u043c\u043e\u043c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439, \u0438\u0437-\u0437\u0430 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432 \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0443 \u0434\u0430\u043d\u043d\u044b\u0445. Async Threading Multiprocessing \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 0.0239 c. 0.0130 c. 0.1599 c. \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 0.9186 \u0441. 0.5087 \u0441. 1.4160 \u0441.","title":"\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435"},{"location":"lab2/task/","text":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0442\u0440\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0438\u0435 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0440\u0435\u0448\u0430\u0442\u044c \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0441\u0443\u043c\u043c\u0443 \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 1 \u0434\u043e 1000000. \u0420\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0434\u043b\u044f \u0443\u0441\u043a\u043e\u0440\u0435\u043d\u0438\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f. \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043d\u0430 Python \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0441 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0430\u0439\u0442\u043e\u0432, \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c \u0438\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435"},{"location":"lab2/task/#1","text":"\u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0442\u0440\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0438\u0435 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0440\u0435\u0448\u0430\u0442\u044c \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0441\u0443\u043c\u043c\u0443 \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 1 \u0434\u043e 1000000. \u0420\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0434\u043b\u044f \u0443\u0441\u043a\u043e\u0440\u0435\u043d\u0438\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"lab2/task/#2","text":"\u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043d\u0430 Python \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0441 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0430\u0439\u0442\u043e\u0432, \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c \u0438\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"lab2/task1/","text":"Async \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u0446\u0438\u043a\u043b \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043c\u0435\u0436\u0434\u0443 \u0437\u0430\u0434\u0430\u0447\u0430\u043c\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u044b \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e. import asyncio import time async def calculate_sum(start, end): return sum(range(start, end)) async def main(): start_time = time.time() tasks = [] ranges = [(1, 250000), (250001, 500000), (500001, 750000), (750001, 1000001)] for start, end in ranges: tasks.append(calculate_sum(start, end)) results = await asyncio.gather(*tasks) total_sum = sum(results) end_time = time.time() print(f\"Async/Await Sum: {total_sum}, Time taken: {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": asyncio.run(main()) Threading \u041f\u043e\u0442\u043e\u043a\u0438 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0437\u0430\u0434\u0430\u0447 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043e\u0434\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. \u0412\u0441\u0435 \u043f\u043e\u0442\u043e\u043a\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u044e\u0442 \u043e\u0434\u043d\u043e \u0438 \u0442\u043e \u0436\u0435 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u043e \u043f\u0430\u043c\u044f\u0442\u0438, \u0447\u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u0434\u0430\u043d\u043d\u044b\u043c \u043f\u0440\u043e\u0441\u0442\u044b\u043c, \u043d\u043e \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043b\u044f \u0438\u0437\u0431\u0435\u0436\u0430\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u043b\u0438\u043a\u0442\u043e\u0432. \u041f\u043e\u0442\u043e\u043a\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439, \u0438 \u043e\u0431\u044b\u0447\u043d\u043e \u0438\u0445 \u043f\u0440\u043e\u0449\u0435 \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438 \u043f\u043e \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044e \u0441 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u043c\u0438. import threading import time def calculate_sum(start, end, results, index): total = sum(range(start, end)) results[index] = total def main(): start_time = time.time() threads = [] results = [0] * 4 # 4 \u043f\u043e\u0434\u0437\u0430\u0434\u0430\u0447\u0438 ranges = [(1, 250000), (250001, 500000), (500001, 750000), (750001, 1000001)] for i, (start, end) in enumerate(ranges): thread = threading.Thread(target=calculate_sum, args=(start, end, results, i)) threads.append(thread) thread.start() for thread in threads: thread.join() total_sum = sum(results) end_time = time.time() print(f\"Threading Sum: {total_sum}, Time taken: {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main() Multiprocessing \u041f\u0440\u043e\u0446\u0435\u0441\u0441\u044b \u2014 \u044d\u0442\u043e \u043d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0435 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u044e\u0442\u0441\u044f \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438. \u0412 \u043e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 \u043f\u043e\u0442\u043e\u043a\u043e\u0432, \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u044b \u043d\u0435 \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u044e\u0442 \u043f\u0430\u043c\u044f\u0442\u044c, \u0447\u0442\u043e \u0443\u0441\u0442\u0440\u0430\u043d\u044f\u0435\u0442 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441 GIL. \u0412 Python \u043a\u0430\u0436\u0434\u044b\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0441\u043e \u0441\u0432\u043e\u0438\u043c \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u043c \u0438\u043d\u0442\u0435\u0440\u043f\u0440\u0435\u0442\u0430\u0442\u043e\u0440\u043e\u043c, \u0447\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e \u043d\u0430 \u043c\u043d\u043e\u0433\u043e\u044f\u0434\u0435\u0440\u043d\u044b\u0445 \u0441\u0438\u0441\u0442\u0435\u043c\u0430\u0445. import multiprocessing import time def calculate_sum(start, end, queue): total = sum(range(start, end)) queue.put(total) def main(): start_time = time.time() processes = [] queue = multiprocessing.Queue() ranges = [(1, 250000), (250001, 500000), (500001, 750000), (750001, 1000001)] for start, end in ranges: process = multiprocessing.Process(target=calculate_sum, args=(start, end, queue)) processes.append(process) process.start() for process in processes: process.join() total_sum = sum(queue.get() for _ in processes) end_time = time.time() print(f\"Multiprocessing Sum: {total_sum}, Time taken: {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 1"},{"location":"lab2/task1/#async","text":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u0446\u0438\u043a\u043b \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043c\u0435\u0436\u0434\u0443 \u0437\u0430\u0434\u0430\u0447\u0430\u043c\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u044b \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e. import asyncio import time async def calculate_sum(start, end): return sum(range(start, end)) async def main(): start_time = time.time() tasks = [] ranges = [(1, 250000), (250001, 500000), (500001, 750000), (750001, 1000001)] for start, end in ranges: tasks.append(calculate_sum(start, end)) results = await asyncio.gather(*tasks) total_sum = sum(results) end_time = time.time() print(f\"Async/Await Sum: {total_sum}, Time taken: {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": asyncio.run(main())","title":"Async"},{"location":"lab2/task1/#threading","text":"\u041f\u043e\u0442\u043e\u043a\u0438 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0437\u0430\u0434\u0430\u0447 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043e\u0434\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. \u0412\u0441\u0435 \u043f\u043e\u0442\u043e\u043a\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u044e\u0442 \u043e\u0434\u043d\u043e \u0438 \u0442\u043e \u0436\u0435 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u043e \u043f\u0430\u043c\u044f\u0442\u0438, \u0447\u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u0434\u0430\u043d\u043d\u044b\u043c \u043f\u0440\u043e\u0441\u0442\u044b\u043c, \u043d\u043e \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043b\u044f \u0438\u0437\u0431\u0435\u0436\u0430\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u043b\u0438\u043a\u0442\u043e\u0432. \u041f\u043e\u0442\u043e\u043a\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439, \u0438 \u043e\u0431\u044b\u0447\u043d\u043e \u0438\u0445 \u043f\u0440\u043e\u0449\u0435 \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438 \u043f\u043e \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044e \u0441 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u043c\u0438. import threading import time def calculate_sum(start, end, results, index): total = sum(range(start, end)) results[index] = total def main(): start_time = time.time() threads = [] results = [0] * 4 # 4 \u043f\u043e\u0434\u0437\u0430\u0434\u0430\u0447\u0438 ranges = [(1, 250000), (250001, 500000), (500001, 750000), (750001, 1000001)] for i, (start, end) in enumerate(ranges): thread = threading.Thread(target=calculate_sum, args=(start, end, results, i)) threads.append(thread) thread.start() for thread in threads: thread.join() total_sum = sum(results) end_time = time.time() print(f\"Threading Sum: {total_sum}, Time taken: {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main()","title":"Threading"},{"location":"lab2/task1/#multiprocessing","text":"\u041f\u0440\u043e\u0446\u0435\u0441\u0441\u044b \u2014 \u044d\u0442\u043e \u043d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0435 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u044e\u0442\u0441\u044f \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438. \u0412 \u043e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 \u043f\u043e\u0442\u043e\u043a\u043e\u0432, \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u044b \u043d\u0435 \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u044e\u0442 \u043f\u0430\u043c\u044f\u0442\u044c, \u0447\u0442\u043e \u0443\u0441\u0442\u0440\u0430\u043d\u044f\u0435\u0442 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441 GIL. \u0412 Python \u043a\u0430\u0436\u0434\u044b\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0441\u043e \u0441\u0432\u043e\u0438\u043c \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u043c \u0438\u043d\u0442\u0435\u0440\u043f\u0440\u0435\u0442\u0430\u0442\u043e\u0440\u043e\u043c, \u0447\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e \u043d\u0430 \u043c\u043d\u043e\u0433\u043e\u044f\u0434\u0435\u0440\u043d\u044b\u0445 \u0441\u0438\u0441\u0442\u0435\u043c\u0430\u0445. import multiprocessing import time def calculate_sum(start, end, queue): total = sum(range(start, end)) queue.put(total) def main(): start_time = time.time() processes = [] queue = multiprocessing.Queue() ranges = [(1, 250000), (250001, 500000), (500001, 750000), (750001, 1000001)] for start, end in ranges: process = multiprocessing.Process(target=calculate_sum, args=(start, end, queue)) processes.append(process) process.start() for process in processes: process.join() total_sum = sum(queue.get() for _ in processes) end_time = time.time() print(f\"Multiprocessing Sum: {total_sum}, Time taken: {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main()","title":"Multiprocessing"},{"location":"lab2/task2/","text":"Async import aiohttp import asyncio from bs4 import BeautifulSoup import psycopg2 import time DB_URL = 'postgresql://postgres:12345@localhost/finances' async def save_to_db(url, title): conn = psycopg2.connect(DB_URL) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() async def parse_and_save(session, url): async with session.get(url) as response: content = await response.text() soup = BeautifulSoup(content, 'html.parser') title = soup.title.string if soup.title else 'No Title' await save_to_db(url, title) print(f\"Processed: {url} with title: {title}\") async def main(): urls = [ 'https://www.yahoo.com', 'https://www.stackoverflow.com', 'https://www.duckduckgo.com', ] start_time = time.time() async with aiohttp.ClientSession() as session: tasks = [parse_and_save(session, url) for url in urls] await asyncio.gather(*tasks) end_time = time.time() print(f\"Async finished in {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": asyncio.run(main()) Threading import threading import requests from bs4 import BeautifulSoup import psycopg2 import time DB_URL = 'postgresql://postgres:12345@localhost/finances' def save_to_db(url, title): conn = psycopg2.connect(DB_URL) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) print(f\"Processed: {url} with title: {title}\") def main(): urls = [ 'https://example.com', 'https://www.python.org', 'https://www.wikipedia.org' # \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0434\u0440\u0443\u0433\u0438\u0435 URL ] start_time = time.time() threads = [] for url in urls: thread = threading.Thread(target=parse_and_save, args=(url,)) threads.append(thread) thread.start() for thread in threads: thread.join() end_time = time.time() print(f\"Threading finished in {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main() Multiprocessing import multiprocessing import requests from bs4 import BeautifulSoup import psycopg2 import time DB_URL = 'postgresql://postgres:12345@localhost/finances' def save_to_db(url, title): conn = psycopg2.connect(DB_URL) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) print(f\"Processed: {url} with title: {title}\") def main(): urls = [ 'https://www.google.com', 'https://www.youtube.com', 'https://www.vk.com', # \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0434\u0440\u0443\u0433\u0438\u0435 URL ] start_time = time.time() processes = [] for url in urls: process = multiprocessing.Process(target=parse_and_save, args=(url,)) processes.append(process) process.start() for process in processes: process.join() end_time = time.time() print(f\"Multiprocessing finished in {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 2"},{"location":"lab2/task2/#async","text":"import aiohttp import asyncio from bs4 import BeautifulSoup import psycopg2 import time DB_URL = 'postgresql://postgres:12345@localhost/finances' async def save_to_db(url, title): conn = psycopg2.connect(DB_URL) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() async def parse_and_save(session, url): async with session.get(url) as response: content = await response.text() soup = BeautifulSoup(content, 'html.parser') title = soup.title.string if soup.title else 'No Title' await save_to_db(url, title) print(f\"Processed: {url} with title: {title}\") async def main(): urls = [ 'https://www.yahoo.com', 'https://www.stackoverflow.com', 'https://www.duckduckgo.com', ] start_time = time.time() async with aiohttp.ClientSession() as session: tasks = [parse_and_save(session, url) for url in urls] await asyncio.gather(*tasks) end_time = time.time() print(f\"Async finished in {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": asyncio.run(main())","title":"Async"},{"location":"lab2/task2/#threading","text":"import threading import requests from bs4 import BeautifulSoup import psycopg2 import time DB_URL = 'postgresql://postgres:12345@localhost/finances' def save_to_db(url, title): conn = psycopg2.connect(DB_URL) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) print(f\"Processed: {url} with title: {title}\") def main(): urls = [ 'https://example.com', 'https://www.python.org', 'https://www.wikipedia.org' # \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0434\u0440\u0443\u0433\u0438\u0435 URL ] start_time = time.time() threads = [] for url in urls: thread = threading.Thread(target=parse_and_save, args=(url,)) threads.append(thread) thread.start() for thread in threads: thread.join() end_time = time.time() print(f\"Threading finished in {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main()","title":"Threading"},{"location":"lab2/task2/#multiprocessing","text":"import multiprocessing import requests from bs4 import BeautifulSoup import psycopg2 import time DB_URL = 'postgresql://postgres:12345@localhost/finances' def save_to_db(url, title): conn = psycopg2.connect(DB_URL) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) print(f\"Processed: {url} with title: {title}\") def main(): urls = [ 'https://www.google.com', 'https://www.youtube.com', 'https://www.vk.com', # \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u0434\u0440\u0443\u0433\u0438\u0435 URL ] start_time = time.time() processes = [] for url in urls: process = multiprocessing.Process(target=parse_and_save, args=(url,)) processes.append(process) process.start() for process in processes: process.join() end_time = time.time() print(f\"Multiprocessing finished in {end_time - start_time:.4f} seconds\") if __name__ == \"__main__\": main()","title":"Multiprocessing"},{"location":"lab3/task/","text":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f: \u0421\u043e\u0437\u0434\u0430\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 1 \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445: \u0421\u043e\u0437\u0434\u0430\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 2 \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445: \u0421\u043e\u0437\u0434\u0430\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 2 \u0420\u0435\u0443\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u0437\u043e\u0432\u0430 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u043f\u043e http \u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u043c\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 FastAPI \u0434\u043b\u044f \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0438\u043b\u0438 \u0432\u043e\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u043e\u0439 socket \u0438\u043b\u0438 \u043f\u043e\u0434\u043e\u0431\u043d\u044b\u043c\u0438. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0435\u043d\u0434\u043f\u043e\u0438\u043d\u0442, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0441 URL \u0434\u043b\u044f \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430, \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u043f\u0430\u0440\u0441\u0435\u0440\u0443 (\u0437\u0430\u043f\u0443\u0449\u0435\u043d\u043d\u043e\u043c\u0443 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u043c \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0435) \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0442\u044c \u043e\u0442\u0432\u0435\u0442 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u043a\u043b\u0438\u0435\u043d\u0442\u0443.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435"},{"location":"lab3/task/#_1","text":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f: \u0421\u043e\u0437\u0434\u0430\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 1 \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445: \u0421\u043e\u0437\u0434\u0430\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 2 \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445: \u0421\u043e\u0437\u0434\u0430\u043d\u043e \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 2 \u0420\u0435\u0443\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u0437\u043e\u0432\u0430 \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u043f\u043e http \u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u043c\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 FastAPI \u0434\u043b\u044f \u043f\u0430\u0440\u0441\u0435\u0440\u0430 \u0438\u043b\u0438 \u0432\u043e\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u043e\u0439 socket \u0438\u043b\u0438 \u043f\u043e\u0434\u043e\u0431\u043d\u044b\u043c\u0438. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0435\u043d\u0434\u043f\u043e\u0438\u043d\u0442, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0441 URL \u0434\u043b\u044f \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430, \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u043f\u0430\u0440\u0441\u0435\u0440\u0443 (\u0437\u0430\u043f\u0443\u0449\u0435\u043d\u043d\u043e\u043c\u0443 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u043c \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0435) \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0442\u044c \u043e\u0442\u0432\u0435\u0442 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u043a\u043b\u0438\u0435\u043d\u0442\u0443.","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435"},{"location":"lab3/task1/","text":"dockerfile # \u043e\u0431\u0440\u0430\u0437 \u0441 Python FROM python:3.12-slim # \u0440\u0430\u0431\u043e\u0447\u0430\u044f \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044e WORKDIR /app COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt # \u0421\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0435 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0432 \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440 COPY .. . # \u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0441 uvicorn CMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--reload\"] parser.py import aiohttp from bs4 import BeautifulSoup from db import save_to_db from fastapi import HTTPException async def parse_and_save(url: str): print(url) async with aiohttp.ClientSession() as session: async with session.get(url) as response: if response.status != 200: raise HTTPException(status_code=response.status, detail=\"Failed to retrieve the URL\") content = await response.text() soup = BeautifulSoup(content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) return title","title":"\u0417\u0430\u0434\u0430\u0447\u0430 1"},{"location":"lab3/task1/#dockerfile","text":"# \u043e\u0431\u0440\u0430\u0437 \u0441 Python FROM python:3.12-slim # \u0440\u0430\u0431\u043e\u0447\u0430\u044f \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044e WORKDIR /app COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt # \u0421\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0435 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0432 \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440 COPY .. . # \u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0441 uvicorn CMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--reload\"]","title":"dockerfile"},{"location":"lab3/task1/#parserpy","text":"import aiohttp from bs4 import BeautifulSoup from db import save_to_db from fastapi import HTTPException async def parse_and_save(url: str): print(url) async with aiohttp.ClientSession() as session: async with session.get(url) as response: if response.status != 200: raise HTTPException(status_code=response.status, detail=\"Failed to retrieve the URL\") content = await response.text() soup = BeautifulSoup(content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) return title","title":"parser.py"},{"location":"lab3/task2/","text":"dockerfile version: '3.8' services: postgres: image: postgres:latest restart: always environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: 12345 POSTGRES_DB: finances ports: - \"5438:5432\" # Maps host port 5438 to container port 5432 networks: - my-network fastapi: build: context: . dockerfile: Dockerfile # Ensure you have a Dockerfile for the FastAPI app ports: - \"8000:8000\" # Expose FastAPI on port 8000 depends_on: - postgres environment: DB_ADMIN: \"postgresql://postgres:12345@postgres:5432/finances\" # Corrected service name networks: - my-network parser: build: context: ./parser # Path to the parser service directory dockerfile: Dockerfile # Ensure you have a Dockerfile for the parser depends_on: - postgres environment: DB_ADMIN: \"postgresql://postgres:12345@postgres:5432/finances\" # Use the same connection string networks: - my-network networks: my-network: parser.py import aiohttp from bs4 import BeautifulSoup from fastapi import HTTPException import psycopg2 from dotenv import load_dotenv import os load_dotenv() db_url = os.getenv(\"DB_ADMIN\") db_url = f\"{db_url}\" def save_to_db(url, title): conn = psycopg2.connect(db_url) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() async def parse_and_save(url: str): print(url) async with aiohttp.ClientSession() as session: async with session.get(url) as response: if response.status != 200: raise HTTPException(status_code=response.status, detail=\"Failed to retrieve the URL\") content = await response.text() soup = BeautifulSoup(content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) return title main .py from fastapi import FastAPI, Depends, HTTPException from models import * from db import * from parser.parser import * app = FastAPI() @app.on_event(\"startup\") def on_startup(): init_db() @app.post(\"/parse\") async def parse(request: ParseRequest): url = request.url title = await parse_and_save(url) return {\"url\": url, \"title\": title} @app.get(\"/parse\") def get_pages(db: Session = Depends(get_db)): return db.query(Page).all() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} @app.get(\"/user/{user_id}\", response_model=UserDisplay) def get_user(user_id: int, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.get(\"/users\", response_model=List[User]) def get_users(db: Session = Depends(get_db)): return db.query(User).all() @app.post(\"/user\") def create_user(user: UserBase, db: Session = Depends(get_db)): db_user = User(**user.dict()) db.add(db_user) db.commit() db.refresh(db_user) return db_user @app.delete(\"/user/{user_id}\") def delete_user(user_id: int, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") db.delete(db_user) db.commit() return {\"message\": \"User deleted successfully\"} @app.patch(\"/user/{user_id}\") def update_user(user_id: int, user: UserBase, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") for attr, value in user.dict().items(): setattr(db_user, attr, value) db.commit() db.refresh(db_user) return db_user # Endpoints for Budget CRUD operations @app.get(\"/budget/{budget_id}\", response_model=BudgetDisplay) def get_budget(budget_id: int, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") return db_budget @app.get(\"/budgets\", response_model=List[Budget]) def get_budgets(db: Session = Depends(get_db)): return db.query(Budget).all() @app.post(\"/budget\") def create_budget(budget: BudgetBase, db: Session = Depends(get_db)): db_budget = Budget(**budget.dict()) db.add(db_budget) db.commit() db.refresh(db_budget) return db_budget @app.delete(\"/budget/{budget_id}\") def delete_budget(budget_id: int, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") db.delete(db_budget) db.commit() return {\"message\": \"Budget deleted successfully\"} @app.patch(\"/budget/{budget_id}\") def update_budget(budget_id: int, budget: BudgetBase, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") for attr, value in budget.dict().items(): setattr(db_budget, attr, value) db.commit() db.refresh(db_budget) return db_budget # Endpoints for Category CRUD operations @app.get(\"/category/{category_id}\", response_model=CategoryDisplay) def get_category(category_id: int, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") return db_category @app.get(\"/categories\", response_model=List[Category]) def get_categories(db: Session = Depends(get_db)): return db.query(Category).all() @app.post(\"/category\") def create_category(category: CategoryBase, db: Session = Depends(get_db)): db_category = Category(**category.dict()) db.add(db_category) db.commit() db.refresh(db_category) return db_category @app.delete(\"/category/{category_id}\") def delete_category(category_id: int, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") db.delete(db_category) db.commit() return {\"message\": \"Category deleted successfully\"} @app.patch(\"/category/{category_id}\") def update_category(category_id: int, category: CategoryBase, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") for attr, value in category.dict().items(): setattr(db_category, attr, value) db.commit() db.refresh(db_category) return db_category # Endpoints for Income CRUD operations @app.get(\"/income/{income_id}\", response_model=IncomeDisplay) def get_income(income_id: int, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") return db_income @app.get(\"/incomes\", response_model=List[Income]) def get_incomes(db: Session = Depends(get_db)): return db.query(Income).all() @app.post(\"/income\") def create_income(income: IncomeBase, db: Session = Depends(get_db)): db_income = Income(**income.dict()) db.add(db_income) db.commit() db.refresh(db_income) return db_income @app.delete(\"/income/{income_id}\") def delete_income(income_id: int, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") db.delete(db_income) db.commit() return {\"message\": \"Income deleted successfully\"} @app.patch(\"/income/{income_id}\") def update_income(income_id: int, income: IncomeBase, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") for attr, value in income.dict().items(): setattr(db_income, attr, value) db.commit() db.refresh(db_income) return db_income # Endpoints for Expense CRUD operations @app.get(\"/expense/{expense_id}\", response_model=ExpenseDisplay) def get_expense(expense_id: int, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") return db_expense @app.get(\"/expenses\", response_model=List[Expense]) def get_expenses(db: Session = Depends(get_db)): return db.query(Expense).all() @app.post(\"/expense\") def create_expense(expense: ExpenseBase, db: Session = Depends(get_db)): db_expense = Expense(**expense.dict()) db.add(db_expense) db.commit() db.refresh(db_expense) return db_expense @app.delete(\"/expense/{expense_id}\") def delete_expense(expense_id: int, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") db.delete(db_expense) db.commit() return {\"message\": \"Expense deleted successfully\"} @app.patch(\"/expense/{expense_id}\") def update_expense(expense_id: int, expense: ExpenseBase, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") for attr, value in expense.dict().items(): setattr(db_expense, attr, value) db.commit() db.refresh(db_expense) return db_expense","title":"\u0417\u0430\u0434\u0430\u0447\u0430 2"},{"location":"lab3/task2/#dockerfile","text":"version: '3.8' services: postgres: image: postgres:latest restart: always environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: 12345 POSTGRES_DB: finances ports: - \"5438:5432\" # Maps host port 5438 to container port 5432 networks: - my-network fastapi: build: context: . dockerfile: Dockerfile # Ensure you have a Dockerfile for the FastAPI app ports: - \"8000:8000\" # Expose FastAPI on port 8000 depends_on: - postgres environment: DB_ADMIN: \"postgresql://postgres:12345@postgres:5432/finances\" # Corrected service name networks: - my-network parser: build: context: ./parser # Path to the parser service directory dockerfile: Dockerfile # Ensure you have a Dockerfile for the parser depends_on: - postgres environment: DB_ADMIN: \"postgresql://postgres:12345@postgres:5432/finances\" # Use the same connection string networks: - my-network networks: my-network:","title":"dockerfile"},{"location":"lab3/task2/#parserpy","text":"import aiohttp from bs4 import BeautifulSoup from fastapi import HTTPException import psycopg2 from dotenv import load_dotenv import os load_dotenv() db_url = os.getenv(\"DB_ADMIN\") db_url = f\"{db_url}\" def save_to_db(url, title): conn = psycopg2.connect(db_url) cursor = conn.cursor() cursor.execute(\"INSERT INTO page (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() cursor.close() conn.close() async def parse_and_save(url: str): print(url) async with aiohttp.ClientSession() as session: async with session.get(url) as response: if response.status != 200: raise HTTPException(status_code=response.status, detail=\"Failed to retrieve the URL\") content = await response.text() soup = BeautifulSoup(content, 'html.parser') title = soup.title.string if soup.title else 'No Title' save_to_db(url, title) return title","title":"parser.py"},{"location":"lab3/task2/#main-py","text":"from fastapi import FastAPI, Depends, HTTPException from models import * from db import * from parser.parser import * app = FastAPI() @app.on_event(\"startup\") def on_startup(): init_db() @app.post(\"/parse\") async def parse(request: ParseRequest): url = request.url title = await parse_and_save(url) return {\"url\": url, \"title\": title} @app.get(\"/parse\") def get_pages(db: Session = Depends(get_db)): return db.query(Page).all() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} @app.get(\"/user/{user_id}\", response_model=UserDisplay) def get_user(user_id: int, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.get(\"/users\", response_model=List[User]) def get_users(db: Session = Depends(get_db)): return db.query(User).all() @app.post(\"/user\") def create_user(user: UserBase, db: Session = Depends(get_db)): db_user = User(**user.dict()) db.add(db_user) db.commit() db.refresh(db_user) return db_user @app.delete(\"/user/{user_id}\") def delete_user(user_id: int, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") db.delete(db_user) db.commit() return {\"message\": \"User deleted successfully\"} @app.patch(\"/user/{user_id}\") def update_user(user_id: int, user: UserBase, db: Session = Depends(get_db)): db_user = db.query(User).filter(User.id == user_id).first() if not db_user: raise HTTPException(status_code=404, detail=\"User not found\") for attr, value in user.dict().items(): setattr(db_user, attr, value) db.commit() db.refresh(db_user) return db_user # Endpoints for Budget CRUD operations @app.get(\"/budget/{budget_id}\", response_model=BudgetDisplay) def get_budget(budget_id: int, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") return db_budget @app.get(\"/budgets\", response_model=List[Budget]) def get_budgets(db: Session = Depends(get_db)): return db.query(Budget).all() @app.post(\"/budget\") def create_budget(budget: BudgetBase, db: Session = Depends(get_db)): db_budget = Budget(**budget.dict()) db.add(db_budget) db.commit() db.refresh(db_budget) return db_budget @app.delete(\"/budget/{budget_id}\") def delete_budget(budget_id: int, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") db.delete(db_budget) db.commit() return {\"message\": \"Budget deleted successfully\"} @app.patch(\"/budget/{budget_id}\") def update_budget(budget_id: int, budget: BudgetBase, db: Session = Depends(get_db)): db_budget = db.query(Budget).filter(Budget.id == budget_id).first() if not db_budget: raise HTTPException(status_code=404, detail=\"Budget not found\") for attr, value in budget.dict().items(): setattr(db_budget, attr, value) db.commit() db.refresh(db_budget) return db_budget # Endpoints for Category CRUD operations @app.get(\"/category/{category_id}\", response_model=CategoryDisplay) def get_category(category_id: int, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") return db_category @app.get(\"/categories\", response_model=List[Category]) def get_categories(db: Session = Depends(get_db)): return db.query(Category).all() @app.post(\"/category\") def create_category(category: CategoryBase, db: Session = Depends(get_db)): db_category = Category(**category.dict()) db.add(db_category) db.commit() db.refresh(db_category) return db_category @app.delete(\"/category/{category_id}\") def delete_category(category_id: int, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") db.delete(db_category) db.commit() return {\"message\": \"Category deleted successfully\"} @app.patch(\"/category/{category_id}\") def update_category(category_id: int, category: CategoryBase, db: Session = Depends(get_db)): db_category = db.query(Category).filter(Category.id == category_id).first() if not db_category: raise HTTPException(status_code=404, detail=\"Category not found\") for attr, value in category.dict().items(): setattr(db_category, attr, value) db.commit() db.refresh(db_category) return db_category # Endpoints for Income CRUD operations @app.get(\"/income/{income_id}\", response_model=IncomeDisplay) def get_income(income_id: int, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") return db_income @app.get(\"/incomes\", response_model=List[Income]) def get_incomes(db: Session = Depends(get_db)): return db.query(Income).all() @app.post(\"/income\") def create_income(income: IncomeBase, db: Session = Depends(get_db)): db_income = Income(**income.dict()) db.add(db_income) db.commit() db.refresh(db_income) return db_income @app.delete(\"/income/{income_id}\") def delete_income(income_id: int, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") db.delete(db_income) db.commit() return {\"message\": \"Income deleted successfully\"} @app.patch(\"/income/{income_id}\") def update_income(income_id: int, income: IncomeBase, db: Session = Depends(get_db)): db_income = db.query(Income).filter(Income.id == income_id).first() if not db_income: raise HTTPException(status_code=404, detail=\"Income not found\") for attr, value in income.dict().items(): setattr(db_income, attr, value) db.commit() db.refresh(db_income) return db_income # Endpoints for Expense CRUD operations @app.get(\"/expense/{expense_id}\", response_model=ExpenseDisplay) def get_expense(expense_id: int, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") return db_expense @app.get(\"/expenses\", response_model=List[Expense]) def get_expenses(db: Session = Depends(get_db)): return db.query(Expense).all() @app.post(\"/expense\") def create_expense(expense: ExpenseBase, db: Session = Depends(get_db)): db_expense = Expense(**expense.dict()) db.add(db_expense) db.commit() db.refresh(db_expense) return db_expense @app.delete(\"/expense/{expense_id}\") def delete_expense(expense_id: int, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") db.delete(db_expense) db.commit() return {\"message\": \"Expense deleted successfully\"} @app.patch(\"/expense/{expense_id}\") def update_expense(expense_id: int, expense: ExpenseBase, db: Session = Depends(get_db)): db_expense = db.query(Expense).filter(Expense.id == expense_id).first() if not db_expense: raise HTTPException(status_code=404, detail=\"Expense not found\") for attr, value in expense.dict().items(): setattr(db_expense, attr, value) db.commit() db.refresh(db_expense) return db_expense","title":"main .py"}]}